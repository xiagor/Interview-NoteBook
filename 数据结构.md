## 时间复杂度推算大O阶方法

1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数（类似求和函数？）中，**只保留最高阶项**。
3. 如果最高阶项存在且不是1，则**去除**与这个项**相乘的常数**。得到的结果就是大O阶。



## 7种内排序对比表

+ 插入排序
  1. 直接插入排序：就是将一个记录插入到已经排好序的序列表
  2. 希尔排序：将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动
+ 选择排序
  3. 简单选择排序：类似冒泡排序，但它是在每一趟找到最小的记录后再直接交换，放到前面排序，就是比冒泡排序的交换移动次数少了。
  4. 堆排序：还没学二叉树，跳跃式排序，不知道什么原理，后面学
+ 交换排序
  5. 冒泡排序：不用说了，最基础排序
  6. 快速排序：最重要的就是找到枢轴（就是中间的值）
+ 归并排序
  7. 归并排序：也是二叉树的，两两比较，不是跳跃式的，稳定，但是占内存

| 类别     | 排序方法     | 时间复杂度      | 空间复杂度 | 稳定性 |
| -------- | ------------ | --------------- | ---------- | ------ |
| 插入排序 | 直接插入排序 | O(n^2)          | O(1)       | 稳定   |
|          | 希尔排序     | O(nlogn)~O(n^2) | O(1)       | 不稳定 |
| 选择排序 | 简单选择排序 | O(n^2)          | O(1)       | 稳定   |
|          | 堆排序       | O(nlogn)        | O(1)       | 不稳定 |
| 交换排序 | 冒泡排序     | O(n^2)          | O(1)       | 稳定   |
|          | 快速排序     | O(nlogn)        | O(logn)    | 不稳定 |
| 归并排序 | 归并排序     | O(nlogn)        | O(n)       | 稳定   |

> 希尔排序要看序列是怎么递增来决定时间复杂度。
>
> 不同场合要考虑不同的算法来应对